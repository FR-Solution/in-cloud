
import dedent                   from 'dedent'

import CodeBlock                from '@theme/CodeBlock'
import {ETCD_ARGS}              from '@site/src/constants/kubernetes/etcdArgs'
import {KUBE_API_ARGS}          from '@site/src/constants/kubernetes/kubeAPIArgs'
import { PORTS }                from '@site/src/constants/kubernetes/ports'
import { CUSTOM_VALUE }         from '@site/src/constants/kubernetes/customValue'
import { COMPONENTS_VERSION }   from '@site/src/constants/kubernetes/componentsVersion'
import { CERTIFICATES }         from '@site/src/constants/kubernetes/certs'
import { KUBELET_COFNIG_DATA } from '@site/src/constants/kubernetes/kubeletConfigData'
import { KUBEADM_COFNIG_DATA } from '@site/src/constants/kubernetes/kubeadmConfigData'
import TabItem from '@theme/TabItem'
import Tabs from '@theme/Tabs'

<details>
<summary>Конфигурация Kubeadm для инициализации кластера</summary>

  <h4>Переменные окружния для шаблона конфигурационного файла</h4>

  <CodeBlock language="bash">
      {dedent`
        export KUBELET_SERVER_PORT=${PORTS.kubeletServer.portNumber}
        export KUBELET_READ_ONLY_PORT=${PORTS.kubeletReadOnlyPort.portNumber}
        export KUBE_APISERVER_PORT=${PORTS.kubeAPIServer.portNumber}
        export ETCD_SERVER_PORT=${PORTS.etcdServer.portNumber}
        export KUBELET_HEALTHZ_PORT=${PORTS.kubeletHealthz.portNumber}
      `}
  </CodeBlock>

  <CodeBlock language="bash">
      {dedent`
        export BASE_K8S_PATH="${CUSTOM_VALUE.kuberneteBaseFolderPath.value}"
        export BASE_KUBELET_PATH="${CUSTOM_VALUE.kuberneteKubeletFolderPath.value}"
        export SERVICE_DNS="${CUSTOM_VALUE.kubernetesDNSAddress.value}"
        export SERVICE_CIDR="${CUSTOM_VALUE.kubernetesServiceCIDR.value}"
        export MACHINE_LOCAL_ADDRESS=${CUSTOM_VALUE.virtualMachineLocalAddress.value}
        export BASE_DOCKER_REGISTRY="${CUSTOM_VALUE.baseDockerRegistry.value}"
        export CLUSTER_NAME="${CUSTOM_VALUE.clusterName.value}"
        export BASE_DOMAIN="${CUSTOM_VALUE.kubernetesBaseDomain.value}"
        export CLUSTER_DOMAIN="${CUSTOM_VALUE.kubernetesClusterDomain.value}"
        export FULL_HOST_NAME="${CUSTOM_VALUE.virtualMachineFullName.value}"
        export KUBERNETES_VERSION="${COMPONENTS_VERSION.kubernetes.value}"
        export ETCD_SERVERS="https://127.0.0.1:$\{ETCD_SERVER_PORT}"
      `}
  </CodeBlock>

  <CodeBlock language="bash">
      {dedent`
        export KUBELET_CURRENT_SERVER_CRT_PATH="${CERTIFICATES.kubeletCurrentServer.crtPath}"
        export KUBERNETES_CA_KEY_PATH="${CERTIFICATES.kubernetesCA.keyPath}"
        export KUBERNETES_CA_CRT_PATH="${CERTIFICATES.kubernetesCA.crtPath}"
        export KUBERNETES_SERVICE_ACCOUNT_KEY_PATH="${CERTIFICATES.kubernetesSA.keyPath}"
        export KUBERNETES_SERVICE_ACCOUNT_CRT_PATH="${CERTIFICATES.kubernetesSA.crtPath}"
        export KUBERNETES_SERVER_KEY_PATH="${CERTIFICATES.kubernetesServer.keyPath}"
        export KUBERNETES_SERVER_CRT_PATH="${CERTIFICATES.kubernetesServer.crtPath}"
        export KUBERNETES_KUBELET_CLIENT_KEY_PATH="${CERTIFICATES.kubernetesKubeletClient.keyPath}"
        export KUBERNETES_KUBELET_CLIENT_CRT_PATH="${CERTIFICATES.kubernetesKubeletClient.crtPath}"
        export KUBERNETES_FRONT_PROXY_CLIENT_KEY_PATH="${CERTIFICATES.kubernetesFrontProxyClient.keyPath}"
        export KUBERNETES_FRONT_PROXY_CLIENT_CRT_PATH="${CERTIFICATES.kubernetesFrontProxyClient.crtPath}"
        export KUBERNETES_FRONT_PROXY_CLIENT_CN="${CERTIFICATES.kubernetesFrontProxyClient.cname}"
        export KUBERNETES_ETCD_CLIENT_KEY_PATH="${CERTIFICATES.kubernetesEtcdClient.keyPath}"
        export KUBERNETES_ETCD_CLIENT_CRT_PATH="${CERTIFICATES.kubernetesEtcdClient.crtPath}"
        export FRONT_PROXY_CA_CRT_PATH="${CERTIFICATES.frontProxyCA.crtPath}"
        export ETCD_SERVER_KEY_PATH="${CERTIFICATES.etcdServer.keyPath}"
        export ETCD_SERVER_CRT_PATH="${CERTIFICATES.etcdServer.crtPath}"
        export ETCD_PEER_KEY_PATH="${CERTIFICATES.etcdPeer.keyPath}"
        export ETCD_PEER_CRT_PATH="${CERTIFICATES.etcdPeer.crtPath}"
        export ETCD_CA_CRT_PATH="${CERTIFICATES.etcdCA.crtPath}"
      `}
  </CodeBlock>

  <h4>Конфигурационный файл kubeadm для инициализации кластера</h4>
  :::warning
  Обратите внимание, что в данном конфигурационном файле этап установки ```addons``` игнорируется.
  :::
  <CodeBlock>
    {dedent`
      cat <<EOF > $\{BASE_K8S_PATH}/kubeadm.conf
      ---
      apiVersion: kubeadm.k8s.io/v1beta3
      kind: InitConfiguration
      skipPhases:
        - addon
      bootstrapTokens:
        - token: "fjt9ex.lwzqgdlvoxtqk4yw"
          description: "kubeadm bootstrap token"
          ttl: "24h"
      certificateKey: 0c00c2fd5c67c37656c00d78a9d7e1f2eb794ef8e4fc3e2a4b532eb14323cd59
      nodeRegistration:
        kubeletExtraArgs:
          cloud-provider: external
          #config: /etc/kubernetes/kubelet/config.yaml
        name: '{{ local_hostname }}'
        ignorePreflightErrors:
          # > При поэтапной сборке кластера, а не выполнении единой команды, 
          # > необходимо указать исключения в параметре ignorePreflightErrors, 
          # > чтобы команда kubeadm init phase preflight выполнялась без препятствий. 
          # > Для этого в nodeRegistration добавляются следующие исключения:
          - FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml
          - FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml
          - FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml
          - FileAvailable--etc-kubernetes-manifests-etcd.yaml
      ---
      apiVersion: kubeadm.k8s.io/v1beta3
      kind: ClusterConfiguration
      controlPlaneEndpoint: api.$\{CLUSTER_NAME}.$\{BASE_DOMAIN}:${KUBE_API_ARGS.securePort.value}
      imageRepository: "$\{BASE_DOCKER_REGISTRY}"
      networking:
        serviceSubnet: "$\{SERVICE_CIDR}"
        dnsDomain: "$\{CLUSTER_DOMAIN}"
      kubernetesVersion: "$\{KUBERNETES_VERSION}"
      etcd:
        local:
          imageRepository: "$\{BASE_DOCKER_REGISTRY}"
          dataDir: "/var/lib/etcd"
          extraArgs:
            auto-compaction-retention: "${ETCD_ARGS.autoCompactionRetention.value}"
            cert-file: "${ETCD_ARGS.certFile.value}"
            client-cert-auth: "${ETCD_ARGS.clientCertAuth.value}"
            data-dir: "${ETCD_ARGS.dataDir.value}"
            election-timeout: "${ETCD_ARGS.electionTimeout.value}"
            experimental-initial-corrupt-check: "true"
            experimental-watch-progress-notify-interval: "5s"
            heartbeat-interval: "${ETCD_ARGS.heartbeatInterval.value}"
            key-file: "${ETCD_ARGS.keyFile.value}"
            logger: "${ETCD_ARGS.logger.value}"
            max-snapshots: "${ETCD_ARGS.maxSnapshots.value}"
            max-wals: "${ETCD_ARGS.maxWals.value}"
            metrics: "${ETCD_ARGS.metrics.value}"
            peer-cert-file: "${ETCD_ARGS.peerCertFile.value}"
            peer-client-cert-auth: "${ETCD_ARGS.peerClientCertAuth.value}"
            peer-key-file: "${ETCD_ARGS.peerKeyFile.value}"
            peer-trusted-ca-file: "${ETCD_ARGS.peerTrustedCAFile.value}"
            snapshot-count: "10000"
            trusted-ca-file: "${ETCD_ARGS.trustedCAFile.value}"
          serverCertSANs:
          - "$\{MACHINE_LOCAL_ADDRESS}"
          - "${ETCD_ARGS.name.value}"
          peerCertSANs:
          - "$\{MACHINE_LOCAL_ADDRESS}"
          - "${ETCD_ARGS.name.value}"
      apiServer:
        extraArgs:
          allow-privileged: "${KUBE_API_ARGS.allowPrivileged.value}"
          anonymous-auth: "${KUBE_API_ARGS.anonymousAuth.value}"
          authorization-mode: "${KUBE_API_ARGS.authorizationMode.value}"
          client-ca-file: "${KUBE_API_ARGS.clientCAFile.value}"
          enable-admission-plugins: "${KUBE_API_ARGS.enableAdmissionPlugins.value}"
          enable-bootstrap-token-auth: "${KUBE_API_ARGS.enableBootstrapTokenAuth.value}"
          etcd-cafile: "${KUBE_API_ARGS.etcdCAFile.value}"
          etcd-certfile: "${KUBE_API_ARGS.etcdCertfile.value}"
          etcd-keyfile: "${KUBE_API_ARGS.etcdKeyfile.value}"
          etcd-servers: "${KUBE_API_ARGS.etcdServers.value}"
          kubelet-client-certificate: "${KUBE_API_ARGS.kubeletClientCertificate.value}"
          kubelet-client-key: "${KUBE_API_ARGS.kubeletClientKey.value}"
          proxy-client-cert-file: "${KUBE_API_ARGS.proxyClientCertFile.value}"
          proxy-client-key-file: "${KUBE_API_ARGS.proxyClientKeyFile.value}"
          requestheader-allowed-names: "${KUBE_API_ARGS.requestheaderAllowedNames.value}"
          requestheader-client-ca-file: "${KUBE_API_ARGS.requestheaderClientCAFile.value}"
          requestheader-extra-headers-prefix: "${KUBE_API_ARGS.requestheaderExtraHeadersPrefix.value}"
          requestheader-group-headers: "${KUBE_API_ARGS.requestheaderGroupHeaders.value}"
          requestheader-username-headers: "${KUBE_API_ARGS.requestheaderUsernameHeaders.value}"
          secure-port: "${KUBE_API_ARGS.securePort.value}"
          service-account-issuer: "${KUBE_API_ARGS.serviceAccountIssuer.value}"
          service-account-key-file: "${KUBE_API_ARGS.serviceAccountKeyFile.value}"
          service-account-signing-key-file: "${KUBE_API_ARGS.serviceAccountSigningKeyFile.value}"
          service-cluster-ip-range: "${KUBE_API_ARGS.serviceClusterIPRange.value}"
          tls-cert-file: "${KUBE_API_ARGS.tlsCertFile.value}"
          tls-private-key-file: "${KUBE_API_ARGS.tlsPrivateKeyFile.value}"
          kubelet-preferred-address-types: InternalIP,ExternalIP,Hostname
          cloud-provider: external
          v: "2"
          event-ttl: "1h0m0s"
          kubernetes-service-node-port: "0"
          max-connection-bytes-per-sec: "0"
          max-requests-inflight: "400"
          min-request-timeout: "1800"
          profiling: "false"
          feature-gates: "RotateKubeletServerCertificate=true"
          audit-log-maxage: "30"
          audit-log-maxbackup: "10"
          audit-log-maxsize: "1000"
          audit-log-mode: "batch"
          runtime-config: "api/all=true"
          enable-aggregator-routing: "true"
          api-audiences: "konnectivity-server"
          oidc-client-id: paas-client
          oidc-username-prefix: "-"
          oidc-username-claim: email
          oidc-groups-claim: groups
          kubelet-timeout: "5s"
          etcd-prefix: /registry

        extraVolumes:
        - name: "k8s-audit"
          hostPath: "/var/log/kubernetes/audit/"
          mountPath: "/var/log/kubernetes/audit/"
          readOnly: false
          pathType: DirectoryOrCreate
        certSANs:
          - "$\{MACHINE_LOCAL_ADDRESS}"
          - "api.$\{CLUSTER_NAME}.$\{BASE_DOMAIN}"
          - "127.0.0.1"

        timeoutForControlPlane: 4m0s

      controllerManager:
        extraArgs:
          authentication-kubeconfig: "$\{BASE_K8S_PATH}/controller-manager.conf"
          authorization-kubeconfig: "$\{BASE_K8S_PATH}/controller-manager.conf"
          kubeconfig: "$\{BASE_K8S_PATH}/controller-manager.conf"
          client-ca-file: "$\{KUBERNETES_CA_CRT_PATH}"
          cluster-signing-cert-file: "$\{KUBERNETES_CA_CRT_PATH}"
          cluster-signing-key-file: "$\{KUBERNETES_CA_KEY_PATH}"
          requestheader-client-ca-file: "$\{FRONT_PROXY_CA_CRT_PATH}"
          root-ca-file: "$\{KUBERNETES_CA_CRT_PATH}"
          service-account-private-key-file: "$\{KUBERNETES_SERVICE_ACCOUNT_KEY_PATH}"
          cluster-name: "$\{CLUSTER_NAME}"
          cluster-signing-duration: "720h"
          concurrent-replicaset-syncs: "20"
          authorization-always-allow-paths: "/healthz,/readyz,/livez,/metrics"
          bind-address: "0.0.0.0"
          controllers: "*,bootstrapsigner,tokencleaner"
          feature-gates: "RotateKubeletServerCertificate=true"
          kube-api-burst: "120"
          kube-api-qps: "100"
          leader-elect: "true"
          namespace-sync-period: "2m0s"
          node-startup-grace-period: "10s"
          v: "2"
          cloud-provider: external
          allocate-node-cidrs: "false"
          concurrent-deployment-syncs: "5"
          concurrent-endpoint-syncs: "5"
          concurrent-namespace-syncs: "10"
          concurrent-resource-quota-syncs: "5"
          horizontal-pod-autoscaler-sync-period: "30s"
          leader-elect-lease-duration: "15s"
          leader-elect-renew-deadline: "10s"
          leader-elect-retry-period: "2s"
          node-monitor-grace-period: "40s"
          node-monitor-period: "5s"
          profiling: "false"
          resource-quota-sync-period: "5m0s"
          terminated-pod-gc-threshold: "0"
          cluster-signing-duration: "720h"
          use-service-account-credentials: "true"

      scheduler:
        extraArgs:
          bind-address: 0.0.0.0
          leader-elect: "true"
EOF`}
  </CodeBlock>
</details>


<Tabs groupId="install-type">

    <TabItem value='Bash'>
        <h4>Создание рабочих директорий</h4>
        <CodeBlock>
          {dedent`
            cat <<EOF > $\{BASE_K8S_PATH}/kubeadm.conf
            ---
            apiVersion: kubeadm.k8s.io/v1beta3
            kind: InitConfiguration
            skipPhases:
              - addon
            bootstrapTokens:
              - token: "fjt9ex.lwzqgdlvoxtqk4yw"
                description: "kubeadm bootstrap token"
                ttl: "24h"
            certificateKey: 0c00c2fd5c67c37656c00d78a9d7e1f2eb794ef8e4fc3e2a4b532eb14323cd59
            nodeRegistration:
              kubeletExtraArgs:
                cloud-provider: external
                config: /etc/kubernetes/kubelet/config.yaml
              name: '{{ local_hostname }}'
              ignorePreflightErrors:
                # > При поэтапной сборке кластера, а не выполнении единой команды, 
                # > необходимо указать исключения в параметре ignorePreflightErrors, 
                # > чтобы команда kubeadm init phase preflight выполнялась без препятствий. 
                # > Для этого в nodeRegistration добавляются следующие исключения:
                - FileAvailable--etc-kubernetes-manifests-kube-apiserver.yaml
                - FileAvailable--etc-kubernetes-manifests-kube-controller-manager.yaml
                - FileAvailable--etc-kubernetes-manifests-kube-scheduler.yaml
                - FileAvailable--etc-kubernetes-manifests-etcd.yaml
            ---
            apiVersion: kubeadm.k8s.io/v1beta3
            kind: ClusterConfiguration
            controlPlaneEndpoint: api.$\{CLUSTER_NAME}.$\{BASE_DOMAIN}:${KUBE_API_ARGS.securePort.value}
            imageRepository: "$\{BASE_DOCKER_REGISTRY}"
            networking:
              serviceSubnet: "$\{SERVICE_CIDR}"
              dnsDomain: "$\{CLUSTER_DOMAIN}"
            kubernetesVersion: "$\{KUBERNETES_VERSION}"
            etcd:
              local:
                imageRepository: "$\{BASE_DOCKER_REGISTRY}"
                dataDir: "/var/lib/etcd"
                extraArgs:
                  auto-compaction-retention: "${ETCD_ARGS.autoCompactionRetention.value}"
                  cert-file: "${ETCD_ARGS.certFile.value}"
                  client-cert-auth: "${ETCD_ARGS.clientCertAuth.value}"
                  data-dir: "${ETCD_ARGS.dataDir.value}"
                  election-timeout: "${ETCD_ARGS.electionTimeout.value}"
                  experimental-initial-corrupt-check: "true"
                  experimental-watch-progress-notify-interval: "5s"
                  heartbeat-interval: "${ETCD_ARGS.heartbeatInterval.value}"
                  key-file: "${ETCD_ARGS.keyFile.value}"
                  logger: "${ETCD_ARGS.logger.value}"
                  max-snapshots: "${ETCD_ARGS.maxSnapshots.value}"
                  max-wals: "${ETCD_ARGS.maxWals.value}"
                  metrics: "${ETCD_ARGS.metrics.value}"
                  peer-cert-file: "${ETCD_ARGS.peerCertFile.value}"
                  peer-client-cert-auth: "${ETCD_ARGS.peerClientCertAuth.value}"
                  peer-key-file: "${ETCD_ARGS.peerKeyFile.value}"
                  peer-trusted-ca-file: "${ETCD_ARGS.peerTrustedCAFile.value}"
                  snapshot-count: "10000"
                  trusted-ca-file: "${ETCD_ARGS.trustedCAFile.value}"
                serverCertSANs:
                - "$\{MACHINE_LOCAL_ADDRESS}"
                - "${ETCD_ARGS.name.value}"
                peerCertSANs:
                - "$\{MACHINE_LOCAL_ADDRESS}"
                - "${ETCD_ARGS.name.value}"
            apiServer:
              extraArgs:
                allow-privileged: "${KUBE_API_ARGS.allowPrivileged.value}"
                anonymous-auth: "${KUBE_API_ARGS.anonymousAuth.value}"
                authorization-mode: "${KUBE_API_ARGS.authorizationMode.value}"
                client-ca-file: "${KUBE_API_ARGS.clientCAFile.value}"
                enable-admission-plugins: "${KUBE_API_ARGS.enableAdmissionPlugins.value}"
                enable-bootstrap-token-auth: "${KUBE_API_ARGS.enableBootstrapTokenAuth.value}"
                etcd-cafile: "${KUBE_API_ARGS.etcdCAFile.value}"
                etcd-certfile: "${KUBE_API_ARGS.etcdCertfile.value}"
                etcd-keyfile: "${KUBE_API_ARGS.etcdKeyfile.value}"
                etcd-servers: "${KUBE_API_ARGS.etcdServers.value}"
                kubelet-client-certificate: "${KUBE_API_ARGS.kubeletClientCertificate.value}"
                kubelet-client-key: "${KUBE_API_ARGS.kubeletClientKey.value}"
                proxy-client-cert-file: "${KUBE_API_ARGS.proxyClientCertFile.value}"
                proxy-client-key-file: "${KUBE_API_ARGS.proxyClientKeyFile.value}"
                requestheader-allowed-names: "${KUBE_API_ARGS.requestheaderAllowedNames.value}"
                requestheader-client-ca-file: "${KUBE_API_ARGS.requestheaderClientCAFile.value}"
                requestheader-extra-headers-prefix: "${KUBE_API_ARGS.requestheaderExtraHeadersPrefix.value}"
                requestheader-group-headers: "${KUBE_API_ARGS.requestheaderGroupHeaders.value}"
                requestheader-username-headers: "${KUBE_API_ARGS.requestheaderUsernameHeaders.value}"
                secure-port: "${KUBE_API_ARGS.securePort.value}"
                service-account-issuer: "${KUBE_API_ARGS.serviceAccountIssuer.value}"
                service-account-key-file: "${KUBE_API_ARGS.serviceAccountKeyFile.value}"
                service-account-signing-key-file: "${KUBE_API_ARGS.serviceAccountSigningKeyFile.value}"
                service-cluster-ip-range: "${KUBE_API_ARGS.serviceClusterIPRange.value}"
                tls-cert-file: "${KUBE_API_ARGS.tlsCertFile.value}"
                tls-private-key-file: "${KUBE_API_ARGS.tlsPrivateKeyFile.value}"
                kubelet-preferred-address-types: InternalIP,ExternalIP,Hostname
                cloud-provider: external
                v: "2"
                event-ttl: "1h0m0s"
                kubernetes-service-node-port: "0"
                max-connection-bytes-per-sec: "0"
                max-requests-inflight: "400"
                min-request-timeout: "1800"
                profiling: "false"
                feature-gates: "RotateKubeletServerCertificate=true"
                audit-log-maxage: "30"
                audit-log-maxbackup: "10"
                audit-log-maxsize: "1000"
                audit-log-mode: "batch"
                runtime-config: "api/all=true"
                enable-aggregator-routing: "true"
                api-audiences: "konnectivity-server"
                oidc-client-id: paas-client
                oidc-username-prefix: "-"
                oidc-username-claim: email
                oidc-groups-claim: groups
                kubelet-timeout: "5s"
                etcd-prefix: /registry
      
              extraVolumes:
              - name: "k8s-audit"
                hostPath: "/var/log/kubernetes/audit/"
                mountPath: "/var/log/kubernetes/audit/"
                readOnly: false
                pathType: DirectoryOrCreate
              certSANs:
                - "$\{MACHINE_LOCAL_ADDRESS}"
                - "api.$\{CLUSTER_NAME}.$\{BASE_DOMAIN}"
                - "127.0.0.1"
      
              timeoutForControlPlane: 4m0s
      
            controllerManager:
              extraArgs:
                authentication-kubeconfig: "$\{BASE_K8S_PATH}/controller-manager.conf"
                authorization-kubeconfig: "$\{BASE_K8S_PATH}/controller-manager.conf"
                kubeconfig: "$\{BASE_K8S_PATH}/controller-manager.conf"
                client-ca-file: "$\{KUBERNETES_CA_CRT_PATH}"
                cluster-signing-cert-file: "$\{KUBERNETES_CA_CRT_PATH}"
                cluster-signing-key-file: "$\{KUBERNETES_CA_KEY_PATH}"
                requestheader-client-ca-file: "$\{FRONT_PROXY_CA_CRT_PATH}"
                root-ca-file: "$\{KUBERNETES_CA_CRT_PATH}"
                service-account-private-key-file: "$\{KUBERNETES_SERVICE_ACCOUNT_KEY_PATH}"
                cluster-name: "$\{CLUSTER_NAME}"
                cluster-signing-duration: "720h"
                concurrent-replicaset-syncs: "20"
                authorization-always-allow-paths: "/healthz,/readyz,/livez,/metrics"
                bind-address: "0.0.0.0"
                controllers: "*,bootstrapsigner,tokencleaner"
                feature-gates: "RotateKubeletServerCertificate=true"
                kube-api-burst: "120"
                kube-api-qps: "100"
                leader-elect: "true"
                namespace-sync-period: "2m0s"
                node-startup-grace-period: "10s"
                v: "2"
                cloud-provider: external
                allocate-node-cidrs: "false"
                concurrent-deployment-syncs: "5"
                concurrent-endpoint-syncs: "5"
                concurrent-namespace-syncs: "10"
                concurrent-resource-quota-syncs: "5"
                horizontal-pod-autoscaler-sync-period: "30s"
                leader-elect-lease-duration: "15s"
                leader-elect-renew-deadline: "10s"
                leader-elect-retry-period: "2s"
                node-monitor-grace-period: "40s"
                node-monitor-period: "5s"
                profiling: "false"
                resource-quota-sync-period: "5m0s"
                terminated-pod-gc-threshold: "0"
                cluster-signing-duration: "720h"
                use-service-account-credentials: "true"
      
            scheduler:
              extraArgs:
                bind-address: 0.0.0.0
                leader-elect: "true"
          EOF`}
        </CodeBlock>

        <h4>Systemd Unit ENV</h4>
        <CodeBlock language="bash">
            {dedent`
            `}
        </CodeBlock>

        <h4>Базовый конфигурационный файл</h4>
        <CodeBlock language="bash">
            {dedent`
            `}
        </CodeBlock>

        <h4>Инструкция шаблонизации</h4>
        <CodeBlock language="bash">
            {dedent`
            `}
        </CodeBlock>

        <h4>Настройка прав</h4>
        <CodeBlock language="bash">
            {dedent`
            `}
        </CodeBlock>

        <h4>Шаблон кастомного конфигурационно файла</h4>
        <CodeBlock language="bash">
            {dedent`
            `}
        </CodeBlock>

        <h4>Systemd Unit Template</h4>
        <CodeBlock language="bash">
            {dedent`
            `}
        </CodeBlock>
    </TabItem>

    <TabItem value='Cloud-init'>
        <h4>Systemd Unit ENV</h4>
        <CodeBlock language="yaml">
            {dedent`
            `}
        </CodeBlock>

        <h4>Базовый конфигурационный файл</h4>
        <CodeBlock language="yaml">
            {dedent`
            `}
        </CodeBlock>

        <h4>Инструкция шаблонизации</h4>
        <CodeBlock language="yaml">
            {dedent`
            `}
        </CodeBlock>

        <h4>Шаблон кастомного конфигурационно файла</h4>
        <CodeBlock language="yaml">
            {dedent`
            `}
        </CodeBlock>

        <h4>Systemd Unit Template</h4>
        <CodeBlock language="yaml">
            {dedent`
            `}
        </CodeBlock>


    </TabItem>

</Tabs>
